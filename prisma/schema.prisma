generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}
 


model User {
  id           String  @id @default(cuid())
  email        String  @unique
  name         String?
  username     String? @unique
  avatarUrl    String?
  bio          String?
  passwordHash String? // <--- NOVO   

  status   UserStatus @default(ONLINE)
  lastSeen DateTime   @default(now())

  lobbies      Lobby[]       @relation("LobbyOwner")
  lobbyMembers LobbyMember[]
  messages     ChatMessage[]

  directParticipants DirectParticipant[]
  directMessages     DirectMessage[]     @relation("DirectMessagesFromUser")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  friendRequestsSent     FriendRequest[] @relation("FriendRequestsSent")
  friendRequestsReceived FriendRequest[] @relation("FriendRequestsReceived")
  friendshipsInitiated   Friendship[]    @relation("UserFriendshipsInitiated")
  friendshipsReceived    Friendship[]    @relation("UserFriendshipsReceived")
}

model FriendRequest {
  id          String              @id @default(cuid())
  fromUser    User                @relation("FriendRequestsSent", fields: [fromUserId], references: [id])
  fromUserId  String
  toUser      User                @relation("FriendRequestsReceived", fields: [toUserId], references: [id])
  toUserId    String
  status      FriendRequestStatus @default(PENDING)
  createdAt   DateTime            @default(now())
  respondedAt DateTime?

  @@unique([fromUserId, toUserId]) // evita pedidos duplicados entre as mesmas pessoas
  @@index([toUserId]) // ajuda a listar "pedidos recebidos"
}

model Friendship {
  id        String   @id @default(cuid())
  userA     User     @relation("UserFriendshipsInitiated", fields: [userAId], references: [id])
  userAId   String
  userB     User     @relation("UserFriendshipsReceived", fields: [userBId], references: [id])
  userBId   String
  createdAt DateTime @default(now())

  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
}

model Game {
  id       String  @id @default(cuid())
  name     String
  slug     String  @unique          // podemos usar o slug do RAWG aqui
  platform String                   // Ex: "PC", "PS5", "Xbox", "Multi"
  genre    String?                  // Ex: "FPS", "MOBA", etc.

  // Novos campos para integração com RAWG
  rawgId             Int?    @unique
  backgroundImageUrl String?

  lobbies   Lobby[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}


model Lobby {
  id          String  @id @default(cuid())
  title       String
  description String?

  status     LobbyStatus @default(OPEN)
  maxPlayers Int

  game   Game   @relation(fields: [gameId], references: [id])
  gameId String

  owner   User   @relation("LobbyOwner", fields: [ownerId], references: [id])
  ownerId String

  members  LobbyMember[]
  messages ChatMessage[]

  language String? // pt-BR, en, es...
  region   String? // BR, NA, EU...

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, gameId, createdAt])
  @@index([ownerId])
}

model LobbyMember {
  id String @id @default(cuid())

  lobby   Lobby  @relation(fields: [lobbyId], references: [id])
  lobbyId String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  role   MemberRole   @default(MEMBER)
  status MemberStatus @default(ACTIVE)

  createdAt DateTime @default(now())

  @@unique([lobbyId, userId])  // um jogador só uma vez por lobby
  @@index([lobbyId])           // buscar membros de um lobby fica rápido
}


model ChatMessage {
  id String @id @default(cuid())

  // contexto da mensagem (por enquanto lobby)
  lobbyId    String
  fromUserId String

  // conteúdo criptografado
  ciphertext Bytes
  iv         Bytes
  authTag    Bytes
  algorithm  String @default("AES-256-GCM")

  createdAt DateTime  @default(now())
  editedAt  DateTime?
  deletedAt DateTime?

  // relations
  lobby    Lobby @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  fromUser User  @relation(fields: [fromUserId], references: [id], onDelete: Cascade)

  @@index([lobbyId, createdAt])
  @@index([fromUserId, createdAt])
}

model DirectConversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  participants DirectParticipant[]
  messages     DirectMessage[]

  @@index([updatedAt])
}

model DirectParticipant {
  id             String @id @default(cuid())
  conversationId String
  userId         String

  conversation DirectConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
}

model DirectMessage {
  id             String @id @default(cuid())
  conversationId String
  fromUserId     String

  // conteúdo criptografado
  ciphertext Bytes
  iv         Bytes
  authTag    Bytes
  algorithm  String @default("AES-256-GCM")

  createdAt DateTime  @default(now())
  editedAt  DateTime?
  deletedAt DateTime?

  conversation DirectConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  fromUser     User               @relation("DirectMessagesFromUser", fields: [fromUserId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([fromUserId, createdAt])
}

enum LobbyStatus {
  OPEN
  FULL
  CLOSED
}

enum MemberRole {
  LEADER
  MEMBER
}

enum MemberStatus {
  ACTIVE
  LEFT
  KICKED
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum UserStatus {
  ONLINE
  AWAY
  BUSY
  INVISIBLE
  OFFLINE
}
